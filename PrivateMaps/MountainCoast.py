##############################################################################
## File: MountainCoast.py
## Author: Otto Laulajainen
## Copyright 2009 Otto Laulajainen
## License: Boost Software License -  Version 1.0 (see below, it's a simple "do as you please, but dont blame me" license)
##############################################################################
##A map script for CIV IV (particularly Fall from Heaven 2)  
##Heavily inspired by J.R.R.Tolkien's Middle Earth as well as  the "Erebus" map script by Rich Marinaccio
##Also a big thanks to Doug McCreary for his Fair_Continent map script
##
##The main point of this script is to creat credible mountain ranges that are large enough to be strategically important without overly 
##disturbing movement. There should rarely be any absolutely critical chokepoints (lone entrances to valleys), but maintaining control 
##of chokepoints is important nevertheless
##This map script is not intended to be perfectly balanced, rather it is meant to be moreless realistic
##See the global variables at the start of the script proper for tweaking
#############################################################################
##Boost Software License - Version 1.0 - August 17th, 2003
##
##Permission is hereby granted, free of charge, to any person or organization
##obtaining a copy of the software and accompanying documentation covered by
##this license (the "Software") to use, reproduce, display, distribute,
##execute, and transmit the Software, and to prepare derivative works of the
##Software, and to permit third-parties to whom the Software is furnished to
##do so, all subject to the following:
##
##The copyright notices in the Software and this entire statement, including
##the above license grant, this restriction and the following disclaimer,
##must be included in all copies of the Software, in whole or in part, and
##all derivative works of the Software, unless such copies or derivative
##works are solely in the form of machine-executable object code generated by
##a source language processor.
##
##THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
##IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
##FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
##SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
##FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
##ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
##DEALINGS IN THE SOFTWARE.
##
##
##############################################################################
## Version 0.9.0
##Initial release, having all locations accessible is not guaranteed yet
##Needs some balancing...
##Check the global variables a little onwards, you should be able to tweak this script quite well with them

##Version 0.9.1
##Got rid of flood plains on plains as well as jungles on mountains
##The map options now mostly work (climate only obeys humidity levels)

##Version 0.9.2
##Allowed removing forests from peaks, as well as making the truly random resource system optional

##Version 0.9.3
##Fixes to river glithes
##Some code cleanup
##Changed map sizes a bit, now closer to square, smaller
##All areas are now accessible, no game breaking bugs known
##Map script takes map sizes into account much better

##Version 0.9.4
##Fixes Tundra/Ice/Snow, increase default amount of deserts a bit

##Version 0.9.5
##Added a new starting position algorithm, practically all starting locations should be away from the miserable little peninsulas, deserts etc.
##Changed the marsh distribution a bit, now correlates much better with the presence of water (rivers, lakes, oceans)
##Scrubs are now in use

##Version 0.9.6
##Moved files around a bit, mostly for convenience of coding
##Heavy changes to starting positions algorithm
##Fixed riviers
##Minor fixes

##Version 0.9.7
##Fixed some regressions form the file split in 0.9.6
##Minor fixes

##Version 1.0.0rc1
##Starting positions system improved

##Version 1.0.0
##Fixed an idiotic bug in starting position system that caused it to (always) default to the normal Civ IV placing algorithm, as well as improving it to take some terrain types into account better
##Minor fixes
##Major "under the hood" changes

##Version 1.0.1
##Tweaks to terrain distribution
##Tweaks to starting position evaluation

##Version 1.0.2
##Recombined the files, now all in one file
##Starting positions are now assigned in random order

##Version 1.1.0a
##Warping version
##Major changes to river system

##Version 1.2.0
##Moisture system tweaked heavily
##Altered hills balance to produce more random hills in grasland areas and less in plains
##Map sizes slightly smaller for "normal" and above
##Significant improvements to the "truly random resource" system

##Version 1.2.1
##Changed to always use multiplayer safe random number generation

##TODO
##Fix all the things mentiond in <http://forums.civfanatics.com/showthread.php?p=763393>
##Version with different latitude?
##"Ancient ruins": have some city ruins, roads etc hanging around
##############################################################################

from math import sqrt
from math import sin
from math import cos
import random
import sys

def MapRandom():
	gr = CyGlobalContext().getGame().getMapRand().get
	return float(gr(1000000, ""))*0.000001

from math import sqrt
from math import sin
from math import cos
import random
import sys

#this stuff is windows only, allows for console color changes
STD_INPUT_HANDLE = -10
STD_OUTPUT_HANDLE= -11
STD_ERROR_HANDLE = -12

FOREGROUND_BLUE = 0x01 # text color contains blue.
FOREGROUND_GREEN= 0x02 # text color contains green.
FOREGROUND_RED  = 0x04 # text color contains red.
FOREGROUND_INTENSITY = 0x08 # text color is intensified.
FOREGROUND = 0x0f
BACKGROUND_BLUE = 0x10 # background color contains blue.
BACKGROUND_GREEN= 0x20 # background color contains green.
BACKGROUND_RED  = 0x40 # background color contains red.
BACKGROUND_INTENSITY = 0x80 # background color is intensified.
BACKGROUND = 0xf0


class vector:
	def __init__(self, x,y):
		self.x=float(x)
		self.y=float(y)
	 
	def dot(self,other):
		return self.x*other.x+self.y*other.y
	
	def absval(self):
		return sqrt(self.x**2+self.y**2)
	
	def subtract(self,other):
		self.x-=other.x
		self.y-=other.y

	def mult(self,val):
		val=float(val)
		self.x*=val
		self.y*=val


has_ctypes=True
try:
	import ctypes
except ImportError:
	has_ctypes=False
#dummy
def set_color(a,b):
	pass
#we only define these the proper way if ctypes is available
if(has_ctypes):
	std_out_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
	def set_color(color, handle=std_out_handle):
	    """(color) -> BOOL
	    
	    Example: set_color(FOREGROUND_GREEN | FOREGROUND_INTENSITY)
	    """
	    bool = ctypes.windll.kernel32.SetConsoleTextAttribute(handle, color)
	    return bool


class MapConstants:
	"""some globally needed variables & functions """
	def __init__(self,x,y):
		#many of these variables are subject to change depending on map size, climate, sealevel etc. settings
		
		#moving the map size here, much better place
		self.x_size=x
		self.y_size=y
		# 0 for none, 1 for x warp (cylinder), 2 for x&y warp (toroid)
		self.WARP=0
		#only effective for warp!=0
		self.N_CONTINENTS=1
		
		#recommend keeping these in the range [1.0,-1.0]
		self.MAX_LATITUDE=1.0
		self.MIN_LATITUDE=0.0
		
		#this is used internally to adjust some parameters to better deal with map size, 1.0 for a standard sized map
		self.MAP_SCALE=self.x_size*self.y_size*0.000417
		#chance for a mountain range to get another one following it (allows for long and bending ranges)
		self.RANGE_CONTINUE=0.95**(1/self.MAP_SCALE)
		#maximum bend angle for mountain ranges (in radians)
		self.RANGE_BENDING=0.5
		#ratio of a single range secions width/length
		self.RANGE_LENGTH=3.0
		#mountain range size multiplier
		self.RANGE_SIZE=3.5
		#size loss for each iteration of the AddLongRange function
		self.RANGE_SIZE_LOSS=0.93**(1/self.MAP_SCALE)
		#mountain size goes down beyond these limits
		self.MAX_MOUNTAIN_LATITUDE=0.95
		self.MIN_MOUNTAIN_LATITUDE=0.1
		#when doing an interpolation in the range [1.0, 0.0] for height calculations, the factor is raised to this power
		#this effects profile of most hills
		self.ALTITUED_CHANGE_POW=2.0

		self.NRANGES=6*self.MAP_SCALE**0.5
		self.NPEAKS=2*self.MAP_SCALE
		self.NLAKES=8

		#moisture_level=0.7
		#how much moisture "appears" from rivers (a bit of unorthodox but gets the "river are is moist" well enough)
		self.RIVER_MOISTURE_ADDITION=18.0
		#this amount of moisture is always added to the 'air', balances moisture differences
		self.CONSTANT_MOISTURE_ADDITION=0.5
		#moisture level, 0.7 is the default, this is not really linear(in terms of terrain type produced), runs around log base 5
		self.MOISTURE_LEVEL=0.7
		#higher number->more rivers
		self.RIVER_SEED=0.2
		#sea level multiplier
		self.SEALEVEL=1.0
		#average amount of EACH resource type PER PLOT when using true rng resources
		self.RESOURCE_LEVEL=0.0014

		# touching these is not recomended
		#height limits (min)
		self.HILL_LIMIT=30
		self.MOUNTAIN_LIMIT=100
		#moisture limits (max)
		self.DESERT_LIMIT=6
		self.PLAINS_LIMIT=8
		self.GRASS_LIMIT=200
		self.MARSH_LIMIT=1000000
		self.TUNDRA_LIMIT=100
		self.SNOW_LIMIT=10
		#moisture(min)
		self.JUNGLE_LIMIT=40
		#forests are a special case, they are more likely to spawn on a wet tile, this is just the minimum
		self.FOREST_LIMIT=self.DESERT_LIMIT
		
		#desert & tundra
		self.MAX_DESERT_LATITUDE=0.35
		self.MIN_TUNDRA_LATITUDE=0.95
		#INT calculatePathDistance(CyPlot pSource, CyPlot pDest)
		#finds the shortest passable path between two CyPlots and returns its length, or returns -1 if no such path exists. Note: the path must be all-land or all-water

		#larger to force starting positions farther apart
		#a large value will result in errors, so leave this one in peace...
		self.STARTING_POSITION_DISTANCE_WEIGHT=0.7
		#some constant to control not so favorably received features
		# 0 or 1
		self.allow_forests_on_mountains=0
		# 0 or 1
		self.use_true_random_resources=0
		
		self.DEBUG_MODE=False
		
	def GetLatitude(self,y):
		"""maps the given y to a latitude in the range [0,1], indicating the distance from the equator """
		temp=float(y)/mc.y_size
		return abs(self.MIN_LATITUDE+temp*(self.MAX_LATITUDE-self.MIN_LATITUDE))
		
	def GetNearestDirs(self,defdir=[0,0]):
		"""gets some of the directions closest to an input vector, 90 degree intervals """
		l2=defdir[0]+defdir[1]
		if(l2==0):
			return [[1,0],[-1,0],[0,1],[0,-1]]
		else:
			
			if(defdir[0]<0):
				if(defdir[1]<0):
					return [[-1,0],[0,-1]]
				elif(defdir[1]>0):
					return [[-1,0],[0,1]]
				else:
					return [[-1,0],[0,1],[0,-1]]
			elif(defdir[0]>0):
				if(defdir[1]<0):
					return [[1,0],[0,-1]]
				elif(defdir[1]>0):
					return [[1,0],[0,1]]
				else:
					return [[1,0],[0,1],[0,-1]]
			else:
				if(defdir[1]<0):
					return [[0,-1],[1,0],[-1,0]]
				elif(defdir[1]>0):
					return [[0,1],[1,0],[-1,0]]
				else:
					#this should never be reached, but playing safe...
					return [[1,0],[-1,0],[0,1],[0,-1]]
					
		return [0,0]
					
				
			

	def dist(self,x1,y1,x2,y2):
		x1=float(x1%self.x_size)
		x2=float(x2%self.x_size)
		y1=float(y1%self.x_size)
		y2=float(y2%self.x_size)
		if(x1>x2):
			x1,x2=x2,x1
		if(y1>y2):
			y1,y2=y2,y1
		d1=((x1-x2)**2+(y1-y2)**2)**0.5
		d2=((x1-x2+self.x_size)**2+(y1-y2+self.y_size)**2)**0.5
		
		if(d1<d2):
			return d1
		else:
			return d2
		
class MapTerrainTypes:
	"""class containing map data in a very final form, waiting to be copied over """
	def __init__(self):
		#if something is set to the mask value, the location should be considered occupied but empty. checking for this should take precedence over any other tests
		#least significant byte dedicated to terrain category
		#least significant bit indicates land 
		self.PLOT_MASK=		0x0000000f
		self.OCEAN=			0x00000002
		self.COAST=			0x00000004
		self.LAND=			0x00000001
		self.HILLS=			0x00000003
		self.PEAK=			0x00000005
		
		self.TERRAIN_MASK=	0x000000f1
		self.GRASSLAND=		0x00000011
		self.PLAINS=		0x00000021
		self.DESERT=		0x00000041
		self.MARSH=			0x00000051
		self.TUNDRA=		0x00000061
		self.SNOW=			0x00000071
		#middle 12 bits are for features
		self.FEATURE_MASK=	0x000fff00
		self.EMPTY=			0x00000000
		self.FOREST_WARM=	0x00000100
		self.FOREST_TEMP= 	0x00000200
		self.FOREST_COLD=	0x00000300
		self.ICE=			0x000fff00
		self.JUNGLE=		0x00000400
		self.OASIS=			0x00001000
		self.FLOOD_PLAINS=	0x00010000
		self.SCRUB=			0x00020000
		#rivers are marked
		self.RIVER_MASK=	0x00f00000
		#self.RIVER=			0x00100000
		self.RIVER_N=		0x00100000
		self.RIVER_E=		0x00200000
		self.RIVER_S=		0x00400000
		self.RIVER_W=		0x00800000
		#most significant byte is for improvemets
		self.IMPROVMENT_MASK=0xff000000
		
		self.data=[]
	
	def InterperateHeightMap(self,HM):
		"""Extracts height map data into an east-to-read format """
		self.data=[0x00000000]*(mc.x_size*mc.y_size)
		#starting position quality
		self.spdata=[0.0]*(mc.x_size*mc.y_size)
		
		for x in range(mc.x_size):
			for y in range(mc.y_size):
				h=HM.HMData(x,y)
				m=HM.MMData(x,y)
				index=HM.GetTileIndex(x,y)
				r=HM.rddata[index]
				#land / ocean
				if(h>mc.MOUNTAIN_LIMIT):
					self.data[index]=self.PEAK
				#we want a slightly reduced amount of hills in clusters and in plains
				elif(h>mc.HILL_LIMIT):
					nohillchance=0.1
					for i in ((0,1),(1,0),(-1,0),(0,-1)):
						if HM.HMData(x+i[0],y+i[1])>mc.MOUNTAIN_LIMIT:
							nohillchance=-100.0
						elif HM.HMData(x+i[0],y+i[1])>mc.HILL_LIMIT:
							nohillchance+=0.05
						if(HM.MMData(x+i[0],y+i[1])<mc.PLAINS_LIMIT):
							nohillchance+=0.05
					if(rng()<nohillchance):
						self.data[index]=self.LAND
					else:
						self.data[index]=self.HILLS
				elif(h>=0):
					self.data[index]=self.LAND
				else:
					self.data[index]=self.OCEAN
					
				#if(HM.WMData(x,y)>0 or r!='C'):
				if(r!='C'):
					if(r=='N'):
						self.data[index]|=self.RIVER_N
					elif(r=='S'):
						self.data[index]|=self.RIVER_S
					elif(r=='E'):
						self.data[index]|=self.RIVER_E
					elif(r=='W'):
						self.data[index]|=self.RIVER_W
					else:
						print "something wrong",x,y
					
				
				#terrain type
				if(h>=0):
					# desert
					if(m<mc.DESERT_LIMIT and mc.GetLatitude(y)<mc.MAX_DESERT_LATITUDE*(rng()*0.2+0.9)):
						self.data[index]|=self.DESERT
					# snow
					elif(mc.GetLatitude(y)>mc.MIN_TUNDRA_LATITUDE*(rng()*0.1+0.9)):
						self.data[index]|=self.SNOW
					#tundra
					elif(mc.GetLatitude(y)>mc.MIN_TUNDRA_LATITUDE*(rng()*0.1+0.8)):
						self.data[index]|=self.TUNDRA
					#plains
					elif(m<mc.PLAINS_LIMIT and rng()<0.9):
						self.data[index]|=self.PLAINS
					#insanely moist terrain becomes marsh (happens more often when there is water around)
					elif(m*sqrt(HM.NWaterAround(x,y))>mc.GRASS_LIMIT and h<mc.HILL_LIMIT):
						self.data[index]|=self.MARSH
					#default to grassland
					else:
						self.data[index]|=self.GRASSLAND
				#coast if there is land nearbly or the water is shallow or we are far enough to the east
				elif(h>-10 or HM.HMData(x-1,y)>=0 or HM.HMData(x+1,y)>=0 or HM.HMData(x,y+1)>=0 or HM.HMData(x,y-1)>=0 or HM.HMData(x-1,y-1)>=0 or HM.HMData(x+1,y-1)>=0 or HM.HMData(x-1,y+1)>=0 or HM.HMData(x+1,y+1)>=0):
					self.data[index]=self.COAST
				else:
					self.data[index]=self.OCEAN
					
				#features
				
				#flood plains
				##jungle
				if(m>mc.JUNGLE_LIMIT and self.data[index]&self.PLOT_MASK!=self.PEAK and mc.GetLatitude(y)<mc.MAX_DESERT_LATITUDE*1.2):
					self.data[index]|=self.JUNGLE
				elif(m>mc.FOREST_LIMIT and rng()<m*0.03 and self.data[index]&self.TERRAIN_MASK!=self.DESERT and ((mc.allow_forests_on_mountains==1 and (HM.HMData(x+1,y)<mc.MOUNTAIN_LIMIT or HM.HMData(x-1,y)<mc.MOUNTAIN_LIMIT or HM.HMData(x,y+1)<mc.MOUNTAIN_LIMIT or HM.HMData(x,y-1)<mc.MOUNTAIN_LIMIT) )or self.data[index]&self.PLOT_MASK!=self.PEAK)):
					if(self.data[index]&self.TERRAIN_MASK==self.TUNDRA or self.data[index]&self.TERRAIN_MASK==self.SNOW):
						self.data[index]|=self.FOREST_COLD
					elif(mc.GetLatitude(y)>0.5*(rng()*0.2+0.8)):
						self.data[index]|=self.FOREST_TEMP
					else:
						self.data[index]|=self.FOREST_WARM

	def Print(self):
		print ""
		print "MapTerrainTypes::Print"
		#print self.Print.im_func
		if(False):
			plotlist=self.GetBestStartingPositions(20)
		else:
			plotlist=[]
		for x in range(0,mc.x_size,5):
			print "%(x) 9d" %{"x":x},

		for y in range(mc.y_size-1,-1,-1):
			set_color(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE)
			if(y%5==0):
				print y," "
			else:
				print "  "
			for x in range(mc.x_size):
				#set color by moisture level
				Q=self.data[y*mc.x_size+x]
				p=Q&self.PLOT_MASK
				t=Q&self.TERRAIN_MASK
				r=Q&self.RIVER_MASK
				
				#background colors
				color=0
				#ocean
				if(p==self.OCEAN):
					color|=BACKGROUND_BLUE
				#coast
				elif(p==self.COAST):
					color|=BACKGROUND_BLUE|BACKGROUND_INTENSITY
				#desert
				elif(t==self.DESERT):
					color|=BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY
				#plains
				elif(t==self.PLAINS):
					color|=BACKGROUND_GREEN | BACKGROUND_RED
				#grassland
				elif(t==self.GRASSLAND):
					color|=BACKGROUND_GREEN 
				#tundra
				elif(t==self.TUNDRA):
					color|=BACKGROUND_BLUE|BACKGROUND_GREEN | BACKGROUND_RED
				#snow
				elif(t==self.SNOW):
					color|=BACKGROUND_BLUE|BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY
				#marsh
				elif(t==self.MARSH):
					color|=BACKGROUND_GREEN | BACKGROUND_INTENSITY
				#else:
				#	color=color|BACKGROUND_GREEN | BACKGROUND_INTENSITY
				else:
					set_color(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE)
					print "%(Q)x " %{"Q":Q}
				
				#foreground colors
				#if(p==self.PEAK):
				#	pass
				if(r!=0):
					color&=BACKGROUND
					color|=FOREGROUND_BLUE | FOREGROUND_INTENSITY
					#pass
				elif(p==self.HILLS):
					pass
				if([x,y] in plotlist):
					color|=FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE| FOREGROUND_INTENSITY

					
				set_color(color)
				
				#print
				if(r):
					if(r==self.RIVER_N):
						print '^',
					elif(r==self.RIVER_S):
						print 'v',
					elif(r==self.RIVER_E):
						print '>',
					elif(r==self.RIVER_W):
						print '<',
					else:
						print '?',
				elif(p==self.PEAK):
					print "M",
				elif([x,y] in plotlist):
					print "X",
				elif(p==self.HILLS):
					print "^",
			#	elif(r==self.RIVER):
			#		print "*",
				else:
					print " ",
				# else:
					# print "?",
		
		set_color(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE)
		
	def SPQPrint(self):
		print ""
		for y in range(mc.y_size-1,-1,-1):
			print "\n",y,"   ",
			for x in range(mc.x_size):
				#print str((self.SPData(x,y)*0.1)%1).rjust(3),
				t=self.spdata[self.GetTileIndex(x,y)]
				if(t<-999): print "X",
				elif(t<0): print " ",
				elif(t<1): print ".",
				elif(t<2): print "*",
				elif(t<5): print "^",
				else: print "A",
	
	def GetTileIndex(self,x,y):
		"""Returns index to specified tile """
		if(x>mc.x_size-1):
			return 0
			#x=mc.x_size-1
		elif(x<0):
			return 0
			#x=0
		if(y>mc.y_size-1):
			return 0
			#y=mc.y_size-1
		elif(y<0):
			return 0
			#y=0
		return int(mc.x_size*y+x)
	def GetPlot(self,x,y):
		return self.data[self.GetTileIndex(x,y)]

	def GetYield(self,plot):
		"""returns a "long time average yield" for a tile (tiles that have yields likely to change during game get an average value)
		May be negative for tiles that actually obstruct production (desert, peaks...)"""
		retval=[0,0,0]
		p=plot&self.PLOT_MASK
		t=plot&self.TERRAIN_MASK
		f=plot&self.FEATURE_MASK
		r=plot&self.RIVER_MASK
		
		if(p==self.COAST):
			retval[0]+=1.5
			retval[2]+=3
			return retval
		elif(p==self.OCEAN):
			retval[0]+=0.5
			retval[2]+=1
			return retval
		elif(p==self.PEAK):
			retval[0]-=2
			retval[1]-=2
			retval[2]-=2
			return retval
		elif(p==self.HILLS):
			retval[0]-=1
			retval[1]+=1
			
		if(t==self.GRASSLAND):
			retval[0]+=2
		elif(t==self.PLAINS):
			retval[0]+=1
			retval[1]+=1
		elif(t==self.DESERT):
			if(r!=0):
				retval[0]+=6
			else:
				retval[0]-=1
		elif(t==self.MARSH):
			retval[0]+=1
		elif(t==self.TUNDRA):
			retval[0]+=1
		elif(t==self.SNOW):
			retval[0]-=0
			
		if(r!=0):
			retval[2]+=2
		
			
				
			
		return retval
	
	def GetStartingPositionQuality(self):
		"""Fills self.spdata with values that correlate with my perception of good starting locations """
		print "GetStartingPositionQuality"
		radius=int(3)
		for x in range(mc.x_size):
			for y in range(mc.y_size):
				value=0
				plot=self.GetPlot(x,y)
				#we want sub-zero for underwater areas
				if(plot&0x00000001==0):
					value=-100
				#same goes for mountains
				elif(plot&self.PLOT_MASK==self.PEAK):
					value=-100
				else:
					#we calculate the total yields of the naked terrain within radius of x,y
					yields=[0,0,0]
					rivers=0
					#keep track of the number of water tiles, we dont want many
					water_tiles=0
					for xx in range(-radius,radius+1):
						#easiest way to ignore edges, reduce point value when near edges
						if(x+xx>mc.x_size-1 or x+xx<0):
							yields[0]-=2
							yields[1]-=2
							yields[2]-=2
						
						for yy in range(-radius,radius+1):
							if(y+yy>mc.y_size-1 or y+yy<0):
								yields[0]-=2
								yields[1]-=2
								yields[2]-=2
							
							plot=self.GetPlot(x+xx,y+yy)
							temp=self.GetYield(plot)
							yields[0]+=temp[0]
							yields[1]+=temp[1]
							yields[2]+=temp[2]
							
							
							if(not plot&self.LAND!=0):
								water_tiles+=1
							if(plot&self.RIVER_MASK!=0):
								rivers+=1
					#average out the production
					yields[0]/=(2*radius)**2
					yields[1]/=(2*radius)**2
					yields[2]/=(2*radius)**2
					#guarantee decent food production
					if(rivers>1.0): rivers=1.0
					value+=yields[0]*abs(yields[0])		+yields[1]*0.5		+yields[2]*0.5			+rivers*0.7			-(water_tiles**1.5)*0.03
					
				self.spdata[self.GetTileIndex(x,y)]=value
				
	def GetBestStartingPositions(self,amount):
		"""Grab some of the best starting positions on the map"""
		self.GetStartingPositionQuality()
		positions=[]
		for y in range (mc.y_size):
			for x in range (mc.x_size):
				i=self.GetTileIndex(x,y)
				plot=self.GetPlot(x,y)
				if(plot&self.LAND==self.LAND and plot&self.PLOT_MASK!=self.PEAK):
					positions.append([self.spdata[i],x,y])
		positions.sort(reverse=True)
		#print positions

		plotlist = positions
		
		x=0
		y=0
		starting_plots=[]
		min_dist=sqrt(mc.x_size*mc.y_size)/(amount**0.6)
		min_dist*=2.0
		print "distance between starting plots",min_dist
		#print "looking for", amount, "plots"
		#for each player
		for playerIndex in range(amount):
			temp=[]
			for i in plotlist:
				if(i[0]>0.0):
					temp.append(i)
			temp.sort(reverse=True)	
			plotlist=temp

			
			#print plotlist
			if len(plotlist)==0:
				print "unable to get requested amount of starting positions(",playerIndex ,"of", amount, ")gotten"
				return starting_plots
					
			x=plotlist[0][1]
			y=plotlist[0][2]
			z=plotlist[0][0]
			plotlist.pop(0)

			#add it to the list of used plots
			starting_plots.append([x,y])
			for j in range(len(plotlist)):
				i=plotlist[j]
				d=mc.dist(x,y,i[1],i[2])
				if(d<min_dist):
					d=(1.0 - d/min_dist)
					
					if(d>0.7):
						plotlist[j][0]=-10.0
						self.spdata[self.GetTileIndex(i[1],i[2])]=-10.0
						#print x,y,i[1],i[2]
						#print plotlist[j]
					else:
						plotlist[j][0]-=d*mc.STARTING_POSITION_DISTANCE_WEIGHT
						self.spdata[self.GetTileIndex(i[1],i[2])]-=d*mc.STARTING_POSITION_DISTANCE_WEIGHT
					
					
			
			print x,y,"added",z,"___________________"
			self.spdata[self.GetTileIndex(x,y)]=-1000
			#self.SPQPrint()
		print "got", len(starting_plots), "out of", amount, "starting plots requested"
		return starting_plots

class HeightMap:
	"""Contains most map data as well as a large collection of functions to manipulate it """
	def __init__(self):
		"""everything zeroed """
		#height map
		self.hmdata=[]
		#river map
		self.wmdata=[]
		self.rddata=[]
		#moisture map
		self.mmdata=[]
		#area isolation data
		self.aidata=[]


	def GenerateHeightMap(self):
		"""Generates a heightmap complete with river system (and moisture calculations) """
		print "GenerateHeightMap"

		self.hmdata=[-20.0]*(mc.x_size*mc.y_size)
		self.wmdata=[0]*(mc.x_size*mc.y_size+1)
		self.rddata=['C']*(mc.x_size*mc.y_size+1)
		self.mmdata=[0]*(mc.x_size*mc.y_size+1)
		self.aidata=[0]*(mc.x_size*mc.y_size+1)
		self.spdata=[0]*(mc.x_size*mc.y_size+1)
		
		#print mc.x_size,mc.y_size
		#for i in range(mc.x_size*mc.y_size):
		#	self.hmdata[i]=-20.0
		#	self.wmdata[i]=0
		#	self.mmdata[i]=0
			
			
		#put a gradient below everything so that we have a clear distinction between land and water
		if(mc.WARP==0):
			self.AddGradient(float(25.0),40.0/float(mc.x_size),(rng()-0.5)*20.0/float(mc.y_size))
			#add some more distinction to the gradient
			self.AddLargeHill(15.0,mc.x_size*0.4,mc.x_size*(rng()*0.2+0.3),mc.y_size*(rng()*0.2+0.9))
			self.AddLargeHill(15.0,mc.x_size*0.4,mc.x_size*(rng()*0.2+0.3),mc.y_size*(rng()*0.2+0.5))
			self.AddLargeHill(15.0,mc.x_size*0.4,mc.x_size*(rng()*0.2+0.3),mc.y_size*(rng()*0.2+0.1))
			
			# add the mountain ranges
			for i in range (int(mc.NRANGES)):
				print "mountain range"
				#self,			sizefactor,			sizeloss,		start_x=-1,						start_y=-1,							direction=-1,			dir_trend=0,blaah=0.9):
				self.AddLongRange(mc.RANGE_SIZE,0.95,     (rng()+i+1)*mc.x_size/mc.NRANGES,  (rng()*0.8+0.2)*mc.y_size,(rng()**2)*3.14159265,0.0,0.9)
				#the version from 0.9.2
				#self.AddLongRange(range_size,0.95,     (rng()+i+1)*mc.x_size/ranges,  (rng()*0.6+0.3)*mc.y_size,(rng()**2)*3.14159265,0.0)

			#make shure we have at leas one considerable open water area
			self.AddLargeHill(-60.0*mc.SEALEVEL,mc.x_size*0.4,0.0,mc.y_size*(rng()*0.4+0.6))	
			self.AddLargeHill(-60.0*mc.SEALEVEL,mc.x_size*0.4,0.0,mc.y_size*(rng()*0.4+0.0))	
			self.GaussianBlur(0.25)
			self.ScaledNoise(25.0,20.0)
			#self.Scale(0.7)
			
			#add the peaks
			#keep them some distance of from the left edge
			for i in range (int(mc.NPEAKS)):
				print "peak"
				self.AddLargeHill(rng()*50+100,(5+rng()*6),mc.x_size*(rng()*0.6+0.4),mc.y_size*rng())
		


			self.Noise(55)
			self.GaussianBlur(1.0)
			self.Noise(35)
			self.RemoveWaterBeyond(mc.x_size*0.4)
			self.GaussianBlur(0.50)
			self.Noise(25)
			self.GaussianBlur(0.1)
			self.Noise(15)
			self.GaussianBlur(0.1)
			self.Noise(5)
			self.GaussianBlur(0.1)
			self.GaussianBlur(0.1)
			self.RemoveLakes()
			
			
			
			#add the lakes
			for i in range (int(mc.NLAKES)):
				print "lake"
				self.AddLargeHill(-rng()*50-50,5*sqrt(mc.MAP_SCALE),mc.x_size*(rng()*0.9+0.1),mc.y_size*rng())
				
			self.NormalizeHills(0.55)
			#now generate the data for rivers
			rivercounter=0
			# set the river starting locations, the higher the terrain the more rivers will spawn
			for i in range(mc.x_size*mc.y_size):
				if(self.hmdata[i]>0.0):
					rivercounter+=self.hmdata[i]*mc.RIVER_SEED
				if(rivercounter<0):
					rivercounter=0
				elif(rivercounter>1000):
					rivercounter-=1000
					self.wmdata[i]=-3
				#some purely rng rivers
				elif(rng()<0.01):
					self.wmdata[i]=-3
			
			# repeatedly have the rivers flow to the best ocean (flow), erode the terrain in their immediate vicinity (erode) and clear the rivers leaving only their starting locations (erode)
			self.hmdata[0]=100
			for j in range(1):
				for i in range(15):
					self.RemoveLakes()
					self.Erode()
					self.Flow()
			#get rid of edges, rivers are done
			self.hmdata[0]=-20

			self.FixIsolatedAreas()
			#and grab a moisture map while were at it...
			self.GenerateMoistureMap()
			self.BlurMoistureMap(0.75)
			self.BlurMoistureMap(0.75)
			self.BlurMoistureMap(0.50)
		else:
			if(mc.N_CONTINENTS==1):
				mc.NRANGES*=2
			mc.MOUNTAIN_LIMIT*=1.9
			mc.RANGE_BENDING*=0.7
			for i in range(mc.N_CONTINENTS):
			# add the mountain ranges
				print "Continent"
				x=int(mc.x_size*((i+0.5)/float(mc.N_CONTINENTS)))
				
				y=int(rng()*mc.y_size)
				min_dist=mc.x_size/mc.N_CONTINENTS
				dr=(1.0/float(mc.N_CONTINENTS+0.0))**2

					
				print x,y	
					
				#self.AddLargeHill(70,mc.x_size/(mc.N_CONTINENTS+3),x+mc.x_size*(rng()-0.5)*dr,y+mc.y_size*(rng()-0.5)*dr)
				mdir=3.14159265*0.5
				for i in range (int(mc.NRANGES)):
					print "mountain range"
					#self,			sizefactor,				sizeloss,		start_x=-1,							start_y=-1,							direction=-1,					dir_trend=0,	blaah=0.9):
					self.AddLongRange(mc.RANGE_SIZE,	0.97,		x+mc.x_size*(rng()-0.5)*dr,		mc.y_size*(rng()*0.5+0.25),		mdir+(rng()*0.2-0.1),	0.0,		0.9)
					#the version from 0.9.2
					#self.AddLongRange(range_size,0.95,     (rng()+i+1)*mc.x_size/ranges,  (rng()*0.6+0.3)*mc.y_size,(rng()**2)*3.14159265,0.0)

				#make sure we have at leas one considerable open water area
				
				
				#add the peaks
				#keep them some distance of from the left edge
				#for i in range (int(mc.NPEAKS)):
				#	print "peak"
				#	self.AddLargeHill(rng()*50+100,(5+rng()*6),mc.x_size*rng(),mc.y_size*rng())
		
			self.ScaledNoise(25.0,20.0)
			self.Noise(25)
			self.GaussianBlur(0.25)
			self.Noise(15)
			self.SweepLand()
				
			self.Noise(7)
			self.ClearEdges()
			self.NormalizeHills(0.55)
			self.GaussianBlur(0.1)
			self.GaussianBlur(0.1)
			self.GaussianBlur(0.1)
			self.GaussianBlur(0.1)
			self.NormalizeHills(0.55)
			self.NormalizeHills(0.55)
			
			
			#add the lakes
			#for i in range (int(mc.NLAKES)):
			#	print "lake"
			#	self.AddLargeHill(-rng()*50-50,5*sqrt(mc.MAP_SCALE),mc.x_size*(rng()*0.9+0.1),mc.y_size*rng())
				
			#self.NormalizeHills(0.55)
			#now generate the data for rivers
			rivercounter=0
			# set the river starting locations, the higher the terrain the more rivers will spawn
			for i in range(mc.x_size*mc.y_size):
				if(self.hmdata[i]>0.0):
					rivercounter+=self.hmdata[i]*mc.RIVER_SEED
				if(rivercounter<0):
					rivercounter=0
				elif(rivercounter>1000):
					rivercounter-=1000
					self.wmdata[i]=-3
				#some purely rng rivers
				elif(rng()<0.03):
					self.wmdata[i]=-3
			
			# repeatedly have the rivers flow to the best ocean (flow), erode the terrain in their immediate vicinity (erode) and clear the rivers leaving only their starting locations (erode)
			self.hmdata[0]=100
			for j in range(1):
				for i in range(5):
					self.Erode()
					self.Flow()
			#get rid of edges, rivers are done
			self.hmdata[0]=-20

			#self.FixIsolatedAreas()
			#and grab a moisture map while were at it...
			self.GenerateMoistureMap()
			self.BlurMoistureMap(0.75)
			self.BlurMoistureMap(0.75)
			self.BlurMoistureMap(0.50)
			
	def AddLongRange(self,sizefactor,sizeloss,start_x=-1,start_y=-1,direction=-1,dir_trend=0,blaah=0.9):
		"""Adds a mountain range recursively"""
		if(sizefactor<0.5):
			return
		size=sizefactor*mc.RANGE_SIZE_LOSS*sizeloss
		x_lim=mc.x_size-2.0*size
		y_lim=mc.y_size-2.0*size
		x1=0.0
		x2=0.0
		y1=0.0
		y2=0.0
		if(dir_trend==0):
			dir_trend+=(rng()-0.5)*mc.RANGE_BENDING*1.0
		else:
			dir_trend=mc.RANGE_BENDING*(rng()-0.5)*1.8
		if(start_x==-1 or start_y==-1 or direction==-1):
			x1=rng()*x_lim+size
			y1=rng()*y_lim+size
			direction=rng()*3.14159265
			#print "new range"
		else:
			x1=start_x
			y1=start_y
			#print "continuing range",blaah,dir_trend
			direction+=dir_trend
		#stop propagating if outside area or too close to left edge
		if(not self.InRange(x1,y1)):
			#print "out of range"
			return
		#lose size faster when not in mid map
		#elif(mc.MAX_MOUNTAIN_LATITUDE*mc.y_size < y1 or mc.MIN_MOUNTAIN_LATITUDE*mc.y_size > y1):
		#	sizeloss*=sizeloss
		#	sizefactor*=sizeloss
			
		this_lenght=sizefactor*mc.RANGE_LENGTH
		x2=x1+cos(direction)*this_lenght*blaah
		y2=y1+sin(direction)*this_lenght*blaah
		#abort if another range is hit
		if(self.HMData(x2,y2)>mc.MOUNTAIN_LIMIT):
			return
		self.AddRange(x1, y1, x2, y2, size)
		
		if(blaah==-1.0 and rng()<mc.RANGE_CONTINUE):
			self.AddLongRange(size,sizeloss,x2,y2,direction,dir_trend,-1.0)
		if(blaah==1.0 and rng()<mc.RANGE_CONTINUE):
			self.AddLongRange(size,sizeloss,x2,y2,direction,dir_trend,1.0)
		if(blaah==0.9 and rng()<mc.RANGE_CONTINUE):
			self.AddLongRange(size,sizeloss,x2,y2,direction,dir_trend,-1.0)
			self.AddLongRange(size,sizeloss,x2,y2,direction,dir_trend,1.0)
	
	def ClearEdges(self):
		if(mc.WARP==0):
			for y in range(mc.y_size):
				self.hmdata[mc.x_size*y]-=50
				self.hmdata[mc.x_size*y+1]-=20
				self.hmdata[mc.x_size*y+2]-=20
				self.hmdata[mc.x_size*y+3]-=10
		elif(mc.WARP==1):
			for x in range(mc.x_size):
				self.hmdata[mc.x_size*0+x]=-150
				self.hmdata[mc.x_size*1+x]-=120
				self.hmdata[mc.x_size*2+x]-=120
				self.hmdata[mc.x_size*3+x]-=110
				
				self.hmdata[mc.x_size*(mc.y_size-1)+x]=-150
				self.hmdata[mc.x_size*(mc.y_size-2)+x]-=120
				self.hmdata[mc.x_size*(mc.y_size-3)+x]-=120
				self.hmdata[mc.x_size*(mc.y_size-4)+x]-=110
				
		
	def HMData(self,x,y):
		"""Shortcut for "self.hmdata[self.GetTileIndex(x,y)]" """
		return self.hmdata[self.GetTileIndex(x,y)]

	def HMDataRiver(self,x,y):
		"""A version of self.HMData that returns huge values near top and bottom of map, helps with river flow control"""
		if(y<2):
			return self.hmdata[self.GetTileIndex(x,y)]+100000
		elif(y>mc.y_size-3):
			return self.hmdata[self.GetTileIndex(x,y)]+100000
		else:
			return self.hmdata[self.GetTileIndex(x,y)]
	
	def WMData(self,x,y):
		"""Shortcut for "self.wmdata[self.GetTileIndex(x,y)]" """
		return self.wmdata[self.GetTileIndex(x,y)]
	
	def MMData(self,x,y):
		"""Shortcut for "self.mmdata[self.GetTileIndex(x,y)]" """
		return self.mmdata[self.GetTileIndex(x,y)]
	
	def SPData(self,x,y):
		"""Shortcut for "self.spdata[self.GetTileIndex(x,y)]" """
		return self.spdata[self.GetTileIndex(x,y)]

	def AIData(self,x,y):
		"""Shortcut for "self.hmdata[self.GetTileIndex(x,y)]" """
		return self.aidata[self.GetTileIndex(x,y)]
	
	def GenerateMoistureMap(self):
		"""Generates moisture data for map """
		print "GenerateMoistureMap"
		#keep track of moisture as a "rintama" (translate when remember to...)
		windheight=[0.0]*mc.y_size
		moisture=[30.0]*mc.y_size
		for x in range(mc.x_size):

			for y in range(mc.y_size):
				windheight[y]-=2
				temp=self.HMData(x,y)-windheight[y]
				#constant moisture addition term
				moisture[y]+=mc.CONSTANT_MOISTURE_ADDITION
				#add moisture to air when we encounter a river
				if(self.WMData(x,y)>0):
					moisture[y]+=mc.RIVER_MOISTURE_ADDITION
					
				#add moisture level if we encounter open water
				if(self.HMData(x,y)<0):
					moisture[y]+=(2.0-mc.GetLatitude(y))*5.0
					if(windheight[y]>0):
						windheight[y]-=1.5
				# if we are going uphill, simulate heavy rainfall
				elif(temp>0):
					self.mmdata[self.GetTileIndex(x,y)]+=moisture[y]*0.1*mc.MOISTURE_LEVEL*temp
					moisture[y]*=0.9**mc.MAP_SCALE
					windheight[y]=self.HMData(x,y)
				#otherwise just give of a bit of rain
				else:
					windheight[y]-=1.5
					self.mmdata[self.GetTileIndex(x,y)]+=moisture[y]*0.2*mc.MOISTURE_LEVEL
					moisture[y]*=0.85**(1/mc.MAP_SCALE)
			#blur moisture levels a bit
			tm=moisture
			for y in range(1,mc.y_size-1):
				moisture[y]*=0.6
				moisture[y]+=(tm[y-1]+tm[y+1])*0.2
	
	def BlurMoistureMap(self, strength):
		"""Blur the moisture map, see GaussianBlur for more info """
		print "BlurMoistureMap"
		if(strength>1.0):
			strength=1.0
		if(strength<-0.5):
			strenght=-0.5
		strength*=0.2
		self.t_data=[0]*(mc.x_size*mc.y_size)
		for i in range(mc.x_size*mc.y_size):
			self.t_data[i]=self.mmdata[i]
		Q=self.GetTileIndex
		for x in range(1,mc.x_size-1):
			for y in range(1,mc.y_size-1):
				self.mmdata[self.GetTileIndex(x,y)]-=self.t_data[Q(x,y)]*(4.0*strength)
				self.mmdata[Q(x,y)]+=self.t_data[Q(x+1,y)]*strength + self.t_data[Q(x-1,y)]*strength + self.t_data[Q(x,y+1)]*strength + self.t_data[Q(x,y-1)]*strength

	def NWaterAround(self,x,y):
		"""Returns number of water tiles around point (both oceans and rivers)"""
		retval=0
		if(self.HMData(x+1,y)<0 or self.WMData(x+1,y)!=0):
			retval+=1
		if(self.HMData(x-1,y)<0 or self.WMData(x-1,y)!=0):
			retval+=1
		if(self.HMData(x,y+1)<0 or self.WMData(x,y+1)!=0):
			retval+=1
		if(self.HMData(x,y-1)<0 or self.WMData(x,y-1)!=0):
			retval+=1
		return retval
	
	def NSameWMValue(self,x,y,value):
		"""Counts squreas around (x,y) with WMData==value """ 
		retval=0
		if(self.WMData(x+1,y)==value):
			retval+=1
		if(self.WMData(x-1,y)==value):
			retval+=1
		if(self.WMData(x,y+1)==value):
			retval+=1
		if(self.WMData(x,y-1)==value):
			retval+=1
			
		return retval

	def GetNextRiver(self,x,y,dx,dy):
		""" Gets the square the river should go to from x,y given dx,dy was the previous square relative to this one
		for use with the final civ IV map generation routine"""
		
		retval=[0,0]
		if(dy>1 or dy<-1 or dx>1 or dx<-1):
			return retval
			
		riverid=self.WMData(x,y)
		if(dx!=1):
			if(self.WMData(x+1,y)==riverid):
				retval=[1,0]
		if(dy!=-1):
			if(self.WMData(x,y-1)==riverid):
				retval=[0,-1]
		if(dy!=1):
			if(self.WMData(x,y+1)==riverid):
				retval=[0,1]
				
		return retval

	def RemoveWaterBeyond(self,x):
		"""Removes all water to the right of point "x" """
		print "RemoveWaterBeyond"
		for i in range (int(x),mc.x_size):
			for j in range(mc.y_size):
				if(self.HMData(i,j)<0.0):
					self.hmdata[self.GetTileIndex(i,j)]=10.0
		#for i in range(mc.x_size*mc.y_size):
		#	if(self.hmdata[i]<10.0):
		#			self.hmdata[i]=10.0

	def RaiseWaterLevel(self):
		"""legacy, buggy ass hell"""
		for x in range(mc.x_size):
			for y in range(mc.y_size):
				if(self.WMData(x,y)==-2):
					h=self.GetMaxWaterLevelLocal(x,y)
					#print h
					if(h>0):
						self.SetWaterLevelRecursive(x,y,h)
						self.wmdata[self.GetTileIndex(x,y)]=self.HMData(x,y)
					
		for i in range(mc.x_size*mc.y_size):
			if(self.wmdata[i]==-1):
				self.wmdata[i]=0

	def RemoveLakes(self):
		"""Removes small water bodies and tidies up other shorelines """
		print "RemoveLakes"
		for x in range (mc.x_size):
			for y in range (mc.y_size):
				if(self.HMData(x,y)<0 and self.NWaterAround(x,y)<2):
					self.hmdata[self.GetTileIndex(x,y)]=10.0

	def Erode(self):
		"""Adjust terrain height around rivers closer to 1 (low grassland) """
		print "Erode"
		for x in range(mc.x_size):
			for y in range(mc.y_size):
				if(self.WMData(x,y)>0):
					self.AddLargeHill((self.HMData(x,y)-15.0)*-0.1,2,x,y)
					self.wmdata[self.GetTileIndex(x,y)]=0
					self.rddata[self.GetTileIndex(x,y)]='C'
	
	def Flow(self):
		"""Simulates river flow, uses self.CanFlowFrom(x,y) extensively (this is just a wrapper for the aforementioned function)"""
		print "Flow"
		for x in range(mc.x_size):
			for y in range(mc.y_size):
				#we try to start flowing from this tile
				tile=[x,y]
				riverid=self.GetTileIndex(x,y)
				
				if(self.WMData(x,y)<-1):
					
					lenght=0
					river_bend_interval=30
					nexttile=self.CanFlowFrom(tile,riverid)
					dir=[[-1,0],[1,0],[0,-1],[0,1]]
					
					#limit the directions a river can flow to
					if(mc.WARP==0):
						dir.remove([1,0])
					else:
						dir.remove([-nexttile[0],-nexttile[1]])
					while(nexttile!=(0,0)):
						lenght+=1
						#allow the river to change main direction every now and then
						if(lenght>river_bend_interval):
							dir=[[-1,0],[1,0],[0,-1],[0,1]]
							dir.remove([-nexttile[0],-nexttile[1]])
							lenght=lenght%river_bend_interval
							
							
						if(nexttile[0]==1):
							self.rddata[self.GetTileIndex(tile[0],tile[1])]='E'
						elif(nexttile[0]==-1):
							self.rddata[self.GetTileIndex(tile[0],tile[1])]='W'
						elif(nexttile[1]==1):
							self.rddata[self.GetTileIndex(tile[0],tile[1])]='N'
						elif(nexttile[1]==-1):
							self.rddata[self.GetTileIndex(tile[0],tile[1])]='S'
							
						tile[0]+=nexttile[0]
						tile[1]+=nexttile[1]

						#old version, stops after finding any water
						#if(self.WMData(tile[0],tile[1])!=0 or self.HMData(tile[0],tile[1])<0):
						
						
						if(self.WMData(tile[0],tile[1])!=0 or self.HMData(tile[0],tile[1])<0):
							#print "hit another water body"
							break
						
						# place the river
						if(self.WMData(tile[0],tile[1])!=-3):
							self.wmdata[self.GetTileIndex(tile[0],tile[1])]=riverid
							#self.rddata[self.GetTileIndex(tile[0],tile[1])]='E'
							
							
						
						nexttile=self.CanFlowFrom(tile,riverid,dir)
						
						
					if(nexttile==[0,0]):
						#print "went wrong"
						self.wmdata[self.GetTileIndex(tile[0],tile[1])]=-2
	
	def CanFlowFrom(self,(x,y),riverid, dir=[[-1,0],[1,0],[0,-1],[0,1]]):
		"""Returns the relative position from (x,y) to the best square for river flow, defaults to going to the first direction present in the tuple unless there is a better squre to flow to (will flow uphill...)
		(This works wonders despite being unorthodox"""
		
		#defines how much the river can flow uphill
		# i know the whole river flow system is quite unorthodox, but it works too well compared to the other (buggy) things i've tried that this i how it shall remain
		tolerance=0
		h=1000000
		retval=dir[0]
		for dx,dy in dir:
			if(self.WMData(x+dx,y+dy)!=riverid and self.WMData(x+dx,y+dy)>=0):
				#prioritize other water bodies as flow targets
				if(self.HMData(x+dx,y+dy)<0 or self.WMData(x+dx,y+dy)!=0):
					h=0
					retval=[dx,dy]
				elif(self.HMData(x+dx,y+dy)<h and self.NSameWMValue(x+dx,y+dy,riverid)<=1):
					h=self.HMDataRiver(x+dx,y+dy)+(rng()-0.5)*20.0
					retval=[dx,dy]
				
		# discriminate agains going to the right so that we dont get loops...
		#if(self.WMData(x+1,y)!=riverid and self.WMData(x+1,y)>=0):
		#	if(self.HMData(x+1,y)<h*0.5 and h<tolerance*0.1 ):
		#		h=self.HMData(x+1,y)
		#		retval=[1,0]
		
		#we are not allowed to flow to squres that contain old rivers
		#if(self.NWaterAround(retval[0],retval[1])>1):
		#	retval=[0,0]
		return retval
	
	def GaussianBlur(self, strength):
		print "GaussianBlur"
		""" Applies gaussian blur with a range of one and a relative strength (1.0 > -0.5) of "strength", 
		1.0 resulting in each square being the average of it neighbors and 0.0 being no change at all, and negative values sharpening terrain"""
		if(strength>1.0):
			strength=1.0
		if(strength<-0.5):
			strenght=-0.5
		strength*=0.2
		self.temp_hmdata=[0]*(mc.x_size*mc.y_size)
		for i in range(mc.x_size*mc.y_size):
			self.temp_hmdata[i]=self.hmdata[i]
		Q=self.GetTileIndex
		for x in range(1,mc.x_size-1):
			for y in range(1,mc.y_size-1):
				self.hmdata[self.GetTileIndex(x,y)]-=self.temp_hmdata[Q(x,y)]*(4.0*strength)
				self.hmdata[Q(x,y)]+=self.temp_hmdata[Q(x+1,y)]*strength + self.temp_hmdata[Q(x-1,y)]*strength + self.temp_hmdata[Q(x,y+1)]*strength + self.temp_hmdata[Q(x,y-1)]*strength

	def ScaledNoise(self,strength,scale):
		"""Applies noise using self.AddLargeHill (in range [strength,-strength]), thus giving it a larger scale"""
		print "ScaledNoise"
		if(scale<1.0):
			return
		for x in range(mc.x_size):
			for y in range(mc.y_size):
				if(rng()<0.1/scale):
					self.AddLargeHill(strength*(rng()-0.5),scale,x,y)

	def Scale(self,scalefactor):
		"""Applies scale factor to the height of all tiles (just multiply them together)""" 
		print "Scale"
		for i in range(mc.x_size*mc.y_size):
			self.hmdata[i]*=scalefactor
	
	def Noise(self, strength):
		"""Adds rng noise in range [strength,-strength] to all tiles """
		print "Noise"
		for i in range (mc.x_size*mc.y_size):
			self.hmdata[i]+=rng()*strength*2.0-strength

	def AddConst(self,const):
		"""Adds a constant term to all squares height """
		for i in range(mc.x_size*mc.y_size):
			self.hmdata[i]+=const
			
	def AddGradient(self, maximum, x_coef, y_coef):
		"""Adds a gradient to terrain height, never raises terrain more that "maximum", x_coef~height at right edge, y_coef~height difference between top and bottom """
		print "AddGradient"
		for x in range(mc.x_size):
			for y in range(mc.y_size):
				add=x*x_coef+(y-mc.y_size*0.5)*y_coef
				if(add>maximum):
					add=maximum
				self.hmdata[self.GetTileIndex(x,y)]+=add

	def SweepLand(self):
		"""Selective extending of land massess eastward"""
		print "GenerateMoistureMap"
		#keep track of moisture as a "rintama" (translate when remember to...)
		bleed=[-1.0]*mc.y_size
		for x in range(mc.x_size*2):
			if(x%int(mc.x_size/mc.N_CONTINENTS)==0):
				for y in range(mc.y_size):
					bleed[y]*=0.1
			for y in range(mc.y_size):
				h=self.HMData(x,y)
				if(h>mc.MOUNTAIN_LIMIT):
					bleed[y]+=h*0.5
				elif(h<20 and bleed[y]>0):
					bleed[y]-=20.0
					self.hmdata[self.GetTileIndex(x,y)]=20
				bleed[y]*=0.7
			#blur moisture levels a bit
			tm=bleed
			for y in range(1,mc.y_size-1):
				bleed[y]*=0.6
				bleed[y]+=(tm[y-1]+tm[y+1])*0.2
	def AddLargeHill(self, height, spread, x, y):
		"""Adds a hill of specified height and radius(spread) """
		if(not self.InRange(x,y)):
			return
		spread=int(spread)
		x=int(x)
		y=int(y)
		#spread=10
		#self.hmdata[self.GetTileIndex(x,y)]=10000
			
		for dx in range(-spread,spread):
			for dy in range(-spread,spread):
				mult=float((spread*spread)-(dx*dx+dy*dy))
				if(mult<=0.0):
					pass
					#mult=0.0
				else:
					mult/=float(spread*spread)
					mult=mult**mc.ALTITUED_CHANGE_POW
					#if(self.InRange(x+dx,y+dy)):
					self.hmdata[self.GetTileIndex(x+dx,y+dy)]+=height*mult
	
	def NormalizeHills(self,amount):
		"""Reduces the amount of hills in large clusters a bit """
		print "NormalizeHills"
		for x in range(mc.x_size):
			for y in range(mc.y_size):
				#we only start cheking at some tiles, much faster this way
				if(rng()<amount):
					#exclude all cases of non-hill nearby
					if(self.HMData(x+1,y)>mc.MOUNTAIN_LIMIT or self.HMData(x+1,y)<mc.HILL_LIMIT):
						pass
					elif(self.HMData(x-1,y)>mc.MOUNTAIN_LIMIT or self.HMData(x-1,y)<mc.HILL_LIMIT):
						pass
					elif(self.HMData(x,y+1)>mc.MOUNTAIN_LIMIT or self.HMData(x,y+1)<mc.HILL_LIMIT):
						pass
					elif(self.HMData(x,y-1)>mc.MOUNTAIN_LIMIT or self.HMData(x,y-1)<mc.HILL_LIMIT):
						pass
					else:
						self.hmdata[self.GetTileIndex(x,y)]=mc.HILL_LIMIT*0.9
						
					# for xx in range (-2,2):
						# if(x+xx>mc.x_size-1 or x+xx<0):
							# continue
						# for yy in range (-2,2):
							# if(y+yy>mc.y_size-1 or y+yy<0):
								# continue
							# h=self.HMData(x+xx,y+yy)
							# if(h<mc.HILL_LIMIT):
								# all_hills=False
								# break
							# elif(h>mc.MOUNTAIN_LIMIT):
								# all_hills=False
								# break
						# if(not all_hills):
							# break
					# if(all_hills):
						# self.hmdata[self.GetTileIndex(x,y)]=mc.HILL_LIMIT*0.9
	
	def Print(self):
		"""Print heightmap to stdout """
		print ""
		for x in range(mc.x_size):
			if(x%5==0):
				print x,
			else:
				print " ",
		for y in range(mc.y_size-1,-1,-1):
			set_color(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE)
			if(y%5==0):
				print y," "
			else:
				print "  "
			for x in range(mc.x_size):
				#set color by moisture level
				color=0
				h=self.HMData(x,y)
				m=self.MMData(x,y)
				#background colors
				if(h<0):
					color=color|BACKGROUND_BLUE
				elif(m<mc.DESERT_LIMIT):
					color=color|BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY
				elif(m<mc.PLAINS_LIMIT):
					color=color|BACKGROUND_GREEN | BACKGROUND_RED
				elif(m<mc.GRASS_LIMIT):
					color=color|BACKGROUND_GREEN 
				else:
					color=color|BACKGROUND_GREEN | BACKGROUND_INTENSITY
				
				#foreground colors
				if(self.SPData(x,y)<-999):
					color=color|FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE |FOREGROUND_INTENSITY
				elif(self.WMData(x,y)>0):
					color=color|FOREGROUND_BLUE |FOREGROUND_INTENSITY
				elif(h>mc.MOUNTAIN_LIMIT):
					pass
					#color=color|FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE |FOREGROUND_INTENSITY
				elif(h>mc.HILL_LIMIT):
					color=color|FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE
				set_color(color)
				if(self.HMData(x,y)<0):
					print " ",
				#elif(self.WMData(x,y)<-1):
				#	print "Q",
				#elif(self.WMData(x,y)!=0):
					#print "*",
				#	print self.WMData(x,y)%10,
				elif(self.SPData(x,y)<-999):
					print "S",
				elif(h>mc.MOUNTAIN_LIMIT):
					print "M",
				elif(h>mc.HILL_LIMIT):
					print "^",
				elif(self.WMData(x,y)>0):
					print "*",
				elif(h>=0):
					print " ",
				else:
					print "?",
		
		set_color(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE)
		print "\n\n\n"
		
		
	def MoisturePrint(self):
		print ""

		for y in range(mc.y_size):
			print ""
			for x in range(mc.x_size):
				if(self.SPData(x,y)>999):
					print "X",
				elif(self.HMData(x,y)>mc.MOUNTAIN_LIMIT):
					print "M",
				elif(self.MMData(x,y)<0):
					print "V",
				elif(self.MMData(x,y)==0):
					print " ",
				elif(self.MMData(x,y)<mc.DESERT_LIMIT):
					print "_",
				elif(self.MMData(x,y)<mc.PLAINS_LIMIT):
					print "^",
				elif(self.MMData(x,y)<mc.GRASS_LIMIT):
					print "|",
				else:
					print "I",
					#print (self.MMData(x,y)%100-self.MMData(x,y)%10)/10,
	def AreaPrint(self):
		for y in range(mc.y_size):
			print ""
			for x in range(mc.x_size):
				if(self.AIData(x,y)!=0):
					print self.AIData(x,y)%10,
				else:
					print " ",
					


					#print (self.MMData(x,y)%100-self.MMData(x,y)%10)/10,
	def GetTile(self,x,y):
		"""Gets tile value form self.hmdata by coordinates """
		if(x>mc.x_size-1):
			return 0
		elif(x<0):
			return 0
		if(y>mc.y_size-1):
			return 0
		elif(y<0):
			return 0
		return self.hmdata[mc.x_size*y+x]

	def GetTileIndex(self,x,y):
		"""Returns index to specified tile """
		x=int(x)
		y=int(y)
		if(mc.WARP==0):
			if(x>mc.x_size-1):
				return 0
				#x=mc.x_size-1
			elif(x<0):
				return 0
				#x=0
			if(y>mc.y_size-1):
				return 0
				#y=mc.y_size-1
			elif(y<0):
				return 0
				#y=0
		elif(mc.WARP==1):
			x=x%mc.x_size
			if(y>mc.y_size-1):
				return 0
			elif(y<0):
				return 0
		elif(mc.WARP==2):
			x=x%mc.x_size
			y=y%mc.y_size
		return mc.x_size*y+x
		
	def InRange(self,x,y):
		if(mc.WARP==2):
			return 1
		else:
			if(y>mc.y_size-1):
				return 0
			elif(y<0):
				return 0
		if(mc.WARP==0):
			if(x>mc.x_size-1):
				return 0
			elif(x<0):
				return 0
			
		
		return 1

	def AddRange(self, start_x,start_y,end_x,end_y, size):
		
		"""Adds a mountain range between specified points"""
		#vector from point C to line AB: AC-(AB.AC)/|B|
		#where (AB.AC)/|B| is clamped between 0.0 and |B|
		A,B=vector(start_x,start_y),vector(end_x,end_y)
		AB=vector(B.x,B.y)
		AC=vector(0.0,0.0)
		AB.subtract(A)
		#if(AB.absval()<0.1):
			#return
		
		if(start_x>end_x):
			temp1=0
			temp2=0
			temp1,temp2=start_x,start_y
			start_x,start_y=end_x,end_y
			end_x,end_y=temp1,temp2
			
		small_y=start_y
		big_y=end_y
		if(start_y>end_y):
			small_y,big_y=end_y,start_y
		#
		for x in range(int(start_x-size*2),int(end_x+size*2)):
			#print ""
			for y in range(int(small_y-size*2),int(big_y+size*2)):
				C=vector(x,y)
				AC=vector(C.x,C.y)
				AC.subtract(A)
				d=AB.dot(AC)/AB.dot(AB)
				
				if(d<0.0):
					d=0.0
				elif(d>1.0):
					d=1.0
				#print d," ",
				AD=vector(AB.x,AB.y)
				AD.mult(d)
				
				DC=vector(AC.x,AC.y)
				#print DC.absval()," ",
				DC.subtract(AD)
				
				#set hm to be the distance from the line AB to  C
				hm=float(DC.absval())
				hm=size-hm
				#hm is in the range [0.0, inf)
				#hm/=size
				#print int(hm),
				if(hm<0.0):
					pass
				else:
					hm=hm**mc.ALTITUED_CHANGE_POW
					#self.hmdata[self.GetTileIndex(x,y)]+=hm*120.0
					self.hmdata[self.GetTileIndex(x,y)]+=(size*hm**2.0)*2.0
				
				#print int(hm),
				#if(hm<0.0):
				#	pass
				#else:
				#	self.hmdata[self.GetTileIndex(x,y)]+=hm*hm*size*2.0
	def GetIsolatedAreas(self):
		print "GetIsolatedAreas"
		del self.aidata
		self.aidata=[0]*(mc.x_size*mc.y_size)
		for y in range(mc.y_size):
			for x in range(mc.x_size):
				if(self.AIData(x,y)==0):
					#use the tile index as ID for the area
					areaID=mc.x_size*y+x
					self.GetSameAreaRecursive(areaID,x,y)
					
	def FixIsolatedAreas(self):
		"""Forces all previously isolated areas to connect to the main open areas or otherwise removes the isolated areas """
		print "FixIsolatedAreas"
		self.GetIsolatedAreas()

		#we assume that the main area has an ID of 1
		connected_areas=[0,1]
		for y in range(mc.y_size):
			for x in range(mc.x_size):
				#if we havent connected this area before, now is the time
				if(not self.AIData(x,y) in connected_areas):
					target=self.GetNearestOtherArea(x,y)
					self.ClearPath(x,y,target[0],target[1])
					self.GetIsolatedAreas()
		
		#is some isolated area still remains, fill it with mountains
		for y in range(mc.y_size):
			for x in range(mc.x_size):
				if(self.AIData(x,y)>1):
					self.hmdata[self.GetTileIndex(x,y)]=mc.MOUNTAIN_LIMIT*1.1
		

	def GetSameAreaRecursive(self, areaID,x,y,direction=[0,0],recursion=0,overwrite_other_areas=False):
		"""Sets all tiles that can be reached from (x,y) (as per CIV IV movement rules) to areaID, recursive function """
		if(areaID==0 or not self.InRange(x,y)):
			return
		#keep the recursion depth limited
		if(recursion>100):
		#	print "recursion depth too high"
		#	return
			pass
		else:
			recursion+=1
		xx=x
		yy=y
		loopcount=0
		#this implementation keeps the recursion count down, previous(simple) one exceeded it pretty easily...
		#first get all the tiles in "direction" marked
		while(xx>=0 and xx<mc.x_size and yy>=0 and yy<mc.y_size):
			#check that the tile is not a mountain tile and that it is not a part of a previous area
			# we consider water to be a valid route, add " and self.HMData(xx,yy)>=0" to the below to change that
			if(self.HMData(xx,yy)<mc.MOUNTAIN_LIMIT and (self.AIData(xx,yy)==0 and overwrite_other_areas==False)):
				self.aidata[self.GetTileIndex(xx,yy)]=areaID
				xx+=direction[0]
				yy+=direction[1]
				loopcount+=1
			#this version will overwrite any areas it finds
			elif(self.HMData(xx,yy)<mc.MOUNTAIN_LIMIT and (self.AIData(xx,yy)!=areaID and overwrite_other_areas==True)):
				self.aidata[self.GetTileIndex(xx,yy)]=areaID
				xx+=direction[0]
				yy+=direction[1]
				loopcount+=1
				
			else:
				 break
		#print recursion,loopcount
		
		#then call this function recursively an all marked locations
		xx=x
		yy=y
		for i in range(loopcount):
			self.GetSameAreaRecursive(areaID,xx+1,yy+1,[+1,+1],recursion,overwrite_other_areas)
			self.GetSameAreaRecursive(areaID,xx+1,yy+0,[+1,+0],recursion,overwrite_other_areas)
			self.GetSameAreaRecursive(areaID,xx+1,yy-1,[+1,-1],recursion,overwrite_other_areas)
			
			self.GetSameAreaRecursive(areaID,xx-1,yy+1,[-1,+1],recursion,overwrite_other_areas)
			self.GetSameAreaRecursive(areaID,xx-1,yy+0,[-1,+0],recursion,overwrite_other_areas)
			self.GetSameAreaRecursive(areaID,xx-1,yy-1,[-1,-1],recursion,overwrite_other_areas)
			
			self.GetSameAreaRecursive(areaID,xx+0,yy+1,[+0,+1],recursion,overwrite_other_areas)
			self.GetSameAreaRecursive(areaID,xx+0,yy-1,[+0,-1],recursion,overwrite_other_areas)
			
			xx+=direction[0]
			yy+=direction[1]
		
	def ClearPath(self,x1,y1,x2,y2):
		"""Clears a simple path to travelable condition between (x1,y1) and (x2,y2)"""
		#keep going until we reach the target
		while(x1!=x2 or y1!=y2):
			#check for mountain
			if(self.HMData(x1,y1)>=mc.MOUNTAIN_LIMIT):
				#force any mountains away
				self.hmdata[self.GetTileIndex(x1,y1)]=mc.MOUNTAIN_LIMIT*0.9
			#move
			if(x1<x2):
				x1+=1
			elif(x1>x2):
				x1-=1
				
			if(y1<y2):
				y1+=1
			elif(y1>y2):
				y1-=1
				
		if(self.HMData(x1,y1)>=mc.MOUNTAIN_LIMIT):
				#force any mountains away
				self.hmdata[self.GetTileIndex(x1,y1)]=mc.MOUNTAIN_LIMIT*0.9
		
				
	def GetNearestOtherArea(self,x,y):
		areaID=self.AIData(x,y)
		if(areaID==0):
			return [0,0]
		radius=1
		#infinite loop, we break or return when we find something
		while(1):
			for i in range(-radius,radius):
				temp=self.AIData(x+i,y+i)
				if(temp>0 and temp!=areaID):
					return [x+i,x+i]
				
				temp=self.AIData(x+i,y-i)
				if(temp>0 and temp!=areaID):
					return [x+i,x-i]
				
				temp=self.AIData(x-i,y-i)
				if(temp>0 and temp!=areaID):
					return [x-i,x-i]
				
				temp=self.AIData(x-i,y+i)
				if(temp>0 and temp!=areaID):
					return [x-i,x+i]
			radius+=1
			#we have a radius as large as map, get out of loop...
			if(radius>mc.x_size and radius>mc.y_size):
				return [0,0]
		
			
	def RiverPrint(self):
		"""Print river data to stdout """
		print ""
		for x in range(mc.x_size):
			if(x%5==0):
				print x,
			else:
				print " ",
		for y in range(mc.y_size-1,-1,-1):
			if(y%5==0):
				print y," "
			else:
				print "  "
			for x in range(mc.x_size):
				if(self.WMData(x,y)==-3):
					print 'X',
				elif(self.WMData(x,y)!=0):
					print self.WMData(x,y)%10,
				else:
					print " ",

rng=MapRandom
#rng=random.random
HM = HeightMap()
TM = MapTerrainTypes()
mc=None
rng=None

#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
##if we are running this script directly, do a test run
if(__name__=="__main__"):
	#global rng
	#global mc
	a=70
	mc=MapConstants(a,int(3.0/4.0*a))
	mc.n_ranges=20
	#raise mc
	rng=random.random
	HM=HeightMap()
	TM=MapTerrainTypes()
	
	HM.GenerateHeightMap()
	#HM.Print()
	#HM.MoisturePrint()
	TM.InterperateHeightMap(HM)
	#TM.GetStartingPositionQuality()
	#HM.RiverPrint()
	#print TM.GetBestStartingPositions(int(rng()*20)+1)
	
	TM.Print()
	#TM.SPQPrint()

#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
##otherwise setup the civ specific stuff
else:

	from CvPythonExtensions import *
	import CvUtil
	import CvMapGeneratorUtil
	def getDescription():
		return unicode("This only shows up in the Play Now menu, and I dont want this script there")


	def getWrapX():
		map = CyMap()
		return (map.getCustomMapOption(5) == 1 or map.getCustomMapOption(5) == 2)
		
	def getWrapY():
		map = CyMap()
		return (map.getCustomMapOption(5) == 2)
	
	#this map has custom options
	def getNumCustomMapOptions():
		return 7
		
	#these get used to the left of the drop down selectors
	def getCustomMapOptionName(argsList):
		print "getCustomMapOptionName",argsList
		index = argsList[0]
		translated_text = [unicode("Peaks"), unicode("Lakes"), unicode("Mountain Ranges"), unicode("Allow forests on mountains"),unicode("Use truly random resources"),unicode("World Warp"),unicode("Land Mass Type")]
		return translated_text[index]
		
	#this tells the script how many entries the drop downs need to have
	def getNumCustomMapOptionValues(argsList):
		print "getNumCustomMapOptionValues",argsList
		index = argsList[0]
		typeCount = [6,6,6,2,4,3,2]
		return typeCount[index]
		

	def getCustomMapOptionDescAt(argsList):
		print "getCustomMapOptionDescAt",argsList
		iOption = argsList[0]
		iSelection = argsList[1]
		selection_names = [
		                  ["None","Very few","Few","Some","Lots","Way too many"],
		                  ["None","Very few","Few","Some","Lots","Wannabe archipalego"],
						  ["None","Very few","Few","Some","Lots","Chokepoints aplenty"],
						  ["Forbid","Allow"],
						  ["Off","Resource Poor","Moderate","Rich"],
						  ["Flat","Spherical","Toroidal"],
						  ["Pangea","Continents"]]
		translated_text = unicode(selection_names[iOption][iSelection])
		return translated_text
		
	#gets the default values for costum options, gives index as argument
	def getCustomMapOptionDefault(argsList):
		index = argsList[0]
		if (index == 0): #asking for peaks
			return 3
		elif(index == 1): #asking for lakes
			return 2
		elif(index==2): #asking mountain ranges
			return 3
		elif(index==3): #allow forests on mountains is off
			return 0
		elif(index==4): #use random resource generation is off
			return 0
		else:
			return 0	#just in case
		
	#this is an advanced map, only shows up if you do custom map
	def isAdvancedMap():
		"""This map should not show up in simple mode"""
		return 1
	#return 0 to disable the sea level selector
	def isSeaLevelMap():
		return 1

	#starts the player's warrior and settler on the same tile if true
	def startHumansOnSameTile():
		return False
		
	#Step 1: the map grid size is determined you map will contain 4 tiles
	# for every grid size, so an 8x4 grid size is 32x16 tiles
	#allows you to override the grid sizes if your map has some particular need
	#in my case, i'm going to force all the grid sizes to be friendly to ocean
	#stripe placement.  Most maps could omit this function.
	def getGridSize(argsList):
		if (argsList[0] == -1): # (-1,) is passed to function on loads
			return []



		# Most map scripts would just return fixed sizes here like:
		# 		WorldSizeTypes.WORLDSIZE_DUEL:		(6,3),
		grid_sizes = {
			WorldSizeTypes.WORLDSIZE_DUEL:		(6,4),
			WorldSizeTypes.WORLDSIZE_TINY:		(8,6),
			WorldSizeTypes.WORLDSIZE_SMALL:		(10,7),
			WorldSizeTypes.WORLDSIZE_STANDARD:	(12,8),
			WorldSizeTypes.WORLDSIZE_LARGE:		(15,10),
			WorldSizeTypes.WORLDSIZE_HUGE:		(21,14)
		}

		[eWorldSize] = argsList
		#duel
		#if(eWorldSize==0):
		#	mc.MAP_SCALE=0.35
		#tiny
		#elif(eWorldSize==1):
		#	mc.MAP_SCALE=0.5
		#small
		#elif(eWorldSize==2):
		#	mc.MAP_SCALE=0.7
		#standard
		#elif(eWorldSize==3):
		#	mc.MAP_SCALE=1.0
		#large 
		#elif(eWorldSize==4):
		#	mc.MAP_SCALE=1.5
		#huge
		#elif(eWorldSize==5):
		#	mc.MAP_SCALE=2.0
			
		return grid_sizes[eWorldSize]

		
	#Step 2: lay out the plot types, which is a sort of broad view of the map tiles
	#basically telling you if you are looking at ocean, land, hill, or mountain
	#plot types: PLOT_OCEAN, PLOT_LAND, PLOT_HILLS ,PLOT_PEAK?
	def generatePlotTypes():
		global rng
		global mc
		global HM
		global TM
		NiTextOut("Setting Plot Types...")
		
		#All the setup before we actually start map generation
		#
		gc = CyGlobalContext()
		map = CyMap()
		mc=MapConstants(map.getGridWidth(),map.getGridHeight())
		if(map.getCustomMapOption(5)==1):
			mc.WARP=1
			mc.MIN_LATITUDE=-1.0
		elif(map.getCustomMapOption(5)==2):
			mc.WARP=2
			mc.MIN_LATITUDE=-1.0
		if(map.getCustomMapOption(6)==1):
			mc.N_CONTINENTS=3
		elif(map.getCustomMapOption(6)==0):
			mc.N_CONTINENTS=1
		#Python randoms are not usable in network games.
		if(CyGame().isNetworkMultiPlayer()):
			rng=MapRandom
		else:
			rng=random.random

			
		#set climate options, this is necessary for proper functioning of the GenerateHeightMap function
		climate = map.getClimate()
		if climate == gc.getInfoTypeForString("CLIMATE_ARID"):
			mc.MOISTURE_LEVEL*=0.3
		elif climate == gc.getInfoTypeForString("CLIMATE_TROPICAL"):
			mc.MOISTURE_LEVEL*=3.5
			
		elif climate == gc.getInfoTypeForString("CLIMATE_COLD"):
			mc.MAX_DESERT_LATITUDE*=0.3
			mc.MIN_TUNDRA_LATITUDE*=0.6
		elif climate == gc.getInfoTypeForString("CLIMATE_ROCKY"):
			#i have no idea what i should do with this...
			pass
		#mc=mc
		
		#defaults to one?
		SEALEVEL=gc.getSeaLevelInfo(map.getSeaLevel()).getSeaLevelChange()+2
		#peaks
		mc.NPEAKS*=map.getCustomMapOption(0)*0.33
		#lakes (not subject to map scale, they get bigger instead)
		mc.NLAKES*=map.getCustomMapOption(1)*0.33
		#mountain ranges
		mc.NRANGES*=map.getCustomMapOption(2)*0.33
		
		#generate the map
		plotTypes = [PlotTypes.PLOT_OCEAN] * (mc.x_size*mc.y_size)
		HM.GenerateHeightMap()
		TM.InterperateHeightMap(HM)
		
		#interpret the map
		# for  in range(x_size):
			# for y in range(y_size):
				# if(HM.GetTile(x,y)>mc.MOUNTAIN_LIMIT):
					# plotTypes[y*x_size+x]=PlotTypes.PLOT_PEAK
				# elif(HM.GetTile(x,y)>mc.HILL_LIMIT):
					# plotTypes[y*x_size+x]=PlotTypes.PLOT_HILLS
				# elif(HM.GetTile(x,y)>=0):
					# plotTypes[y*x_size+x]=PlotTypes.PLOT_LAND
				# else:
					# plotTypes[y*x_size+x]=PlotTypes.PLOT_OCEAN
					
		for i in range(mc.x_size*mc.y_size):
			plot=TM.data[i]
			p=plot&TM.PLOT_MASK
			if(p&TM.LAND==0):
				plotTypes[i]=PlotTypes.PLOT_OCEAN
			elif(p==TM.PEAK):
				plotTypes[i]=PlotTypes.PLOT_PEAK
			elif(p==TM.HILLS):
				plotTypes[i]=PlotTypes.PLOT_HILLS
			else:
				plotTypes[i]=PlotTypes.PLOT_LAND


		
		return plotTypes
		
	#Step 3: now generate the fine terrain, in particular, need to decide if 
	#any land tile is desert, plains, grass, tundra, or snow
	def generateTerrainTypes():		
		NiTextOut("Generating Terrain (Fair Continents) ...")
		gc = CyGlobalContext()
		map = CyMap()
		
		terrainData = [TerrainTypes.NO_TERRAIN]*(mc.x_size*mc.y_size)
		
		terrainDesert = gc.getInfoTypeForString("TERRAIN_DESERT")
		terrainPlains = gc.getInfoTypeForString("TERRAIN_PLAINS")
		terrainSnow = gc.getInfoTypeForString("TERRAIN_SNOW")
		terrainTundra = gc.getInfoTypeForString("TERRAIN_TUNDRA")
		terrainGrass = gc.getInfoTypeForString("TERRAIN_GRASS")
		terrainHill = gc.getInfoTypeForString("TERRAIN_HILL")
		terrainCoast = gc.getInfoTypeForString("TERRAIN_COAST")
		terrainOcean = gc.getInfoTypeForString("TERRAIN_OCEAN")
		terrainPeak = gc.getInfoTypeForString("TERRAIN_PEAK")
		terrainMarsh = gc.getInfoTypeForString("TERRAIN_MARSH")
		
		
		#for every terrain we need to consider in x,y
		for i in range (mc.x_size*mc.y_size):
			plot=TM.data[i]
			p=plot&TM.PLOT_MASK
			t=plot&TM.TERRAIN_MASK
			if(p==TM.OCEAN):
				terrainData[i]=terrainOcean
			elif(p==TM.COAST):
				terrainData[i]=terrainCoast
			#elif(p==TM.PEAK):
			#	terrainData[i]=terrainPeak
			elif(t==TM.DESERT):
				terrainData[i]=terrainDesert
			elif(t==TM.PLAINS):
				terrainData[i]=terrainPlains
			elif(t==TM.GRASSLAND):
				terrainData[i]=terrainGrass
			elif(t==TM.TUNDRA):
				terrainData[i]=terrainTundra
			elif(t==TM.SNOW):
				terrainData[i]=terrainSnow
			elif(t==TM.MARSH):
				terrainData[i]=terrainMarsh
			else:
				terrainData[i]=terrainGrass

		return terrainData

	#Step 4: add features to your terrain	
	#this is responsible for things like oasis, ice floes on the ocean, rivers, goodies ...
	def addFeatures():
		NiTextOut("Adding Features ...")
		mc.x_size
		mc.y_size
		map=CyMap()
		gc = CyGlobalContext()
		pmap = gc.getMap()
		mc.allow_forests_on_mountains=int(map.getCustomMapOption(3))
		
		impGoodyHut = gc.getInfoTypeForString("IMPROVEMENT_GOODY_HUT")
		
		featIce = gc.getInfoTypeForString("FEATURE_ICE")
		featJungle = gc.getInfoTypeForString("FEATURE_JUNGLE")
		featOasis = gc.getInfoTypeForString("FEATURE_OASIS")
		featFlood = gc.getInfoTypeForString("FEATURE_FLOOD_PLAINS")
		featForest = gc.getInfoTypeForString("FEATURE_FOREST")
		featScrub = gc.getInfoTypeForString("FEATURE_SCRUB")
		FOREST_WARM = 0
		FOREST_TEMP = 1
		FOREST_COLD = 2
		#self.FOREST_WARM=	0x00000100
		#self.FOREST_TEMP= 	0x00000200
		#self.FOREST_COLD=	0x00000300
		for x in range(mc.x_size):
			for y in range(mc.y_size):
				plot = pmap.plot(x,y)
				index=y*mc.x_size+x
				
				if(HM.HMData(x,y)<0):
					continue
				elif(TM.data[index]&TM.TERRAIN_MASK==TM.DESERT and plot.isRiver() and TM.data[index]&TM.PLOT_MASK==TM.LAND):
					plot.setFeatureType(featFlood,0)
				elif(TM.data[index]&TM.FEATURE_MASK==TM.FOREST_COLD):
					plot.setFeatureType(featForest,FOREST_COLD)
				elif(TM.data[index]&TM.FEATURE_MASK==TM.FOREST_TEMP):
					plot.setFeatureType(featForest,FOREST_TEMP)
				elif(TM.data[index]&TM.FEATURE_MASK==TM.FOREST_WARM):
					plot.setFeatureType(featForest,FOREST_WARM)
				elif(TM.data[index]&TM.FEATURE_MASK==TM.JUNGLE):
					plot.setFeatureType(featJungle,0)
				
				##goody huts :)
				if(rng()<0.02 and HM.HMData<mc.MOUNTAIN_LIMIT):
					plot.setImprovementType(impGoodyHut)
				
			
		



	# #########
	def normalizeAddRiver():
	    return
	#def normalizeAddLakes():
	#    return
	#def normalizeAddGoodTerrain():
	#    return
	#def normalizeRemoveBadTerrain():
	#    return
	# def normalizeRemoveBadFeatures():
		# gc = CyGlobalContext()
		# map = CyMap()
		# featJungle = gc.getInfoTypeForString("FEATURE_JUNGLE")
		# featForest = gc.getInfoTypeForString("FEATURE_FOREST")
		# featNone = gc.getInfoTypeForString("NO_FEATURE")
		# playerList = []
		# for playerIndex in range(gc.getMAX_CIV_PLAYERS()):
			# player = gc.getPlayer(playerIndex)
			# if player.isEverAlive():
				# civType = player.getCivilizationType()
				##if civType==gc.getInfoTypeForString("CIVILIZATION_LJOSALFAR") or civType==gc.getInfoTypeForString("CIVILIZATION_SVARTALFAR"):
				##	continue
				# plot = player.getStartingPlot()
				# featureType = plot.getFeatureType()
				# if featureType == featJungle or featureType == featForest:
					# plot.setFeatureType(featNone,0)
				# x=plot.getX()
				# y=plot.getY()
				# for i in range(-1,1):
					# plot=map.plot(x+i,y+1)
					# featureType = plot.getFeatureType()
					# if featureType == featJungle or featureType == featForest:
						# plot.setFeatureType(featNone,0)
					
					# plot=map.plot(x-i,y-1)
					# featureType = plot.getFeatureType()
					# if featureType == featJungle or featureType == featForest:
						# plot.setFeatureType(featNone,0)
					
					# plot=map.plot(x-i,y)
					# featureType = plot.getFeatureType()
					# if featureType == featJungle or featureType == featForest:
						# plot.setFeatureType(featNone,0)
		
		
		# return
	#def normalizeAddExtras():
	#    return
	def normalizeRemovePeaks():
	    return
	def addLakes():
	    return
	def getTopLatitude():
		"Default is 90. 75 is past the Arctic Circle"
		return 90

	def getBottomLatitude():
		"Default is -90. -75 is past the Antartic Circle"
		return (CyMap().getCustomMapOption(5) == 1 or CyMap().getCustomMapOption(5) == 2)*-90
		
	def addRivers():
		x_size=mc.x_size
		y_size=mc.y_size
		gc = CyGlobalContext()
		pmap = gc.getMap()
	    
		for x in range(x_size):
			for y in range(y_size):
				r=TM.data[HM.GetTileIndex(x,y)]&TM.RIVER_MASK
				if(r!=0):
					plot=pmap.plot(x,y)
					if(r==TM.RIVER_N):
						plot.setWOfRiver(True,CardinalDirectionTypes.CARDINALDIRECTION_NORTH)
					elif(r==TM.RIVER_S):
						plot=pmap.plot(x,y-1)
						if(not (plot.isWater() or pmap.plot(x,y).isWater())):
							plot.setWOfRiver(True,CardinalDirectionTypes.CARDINALDIRECTION_SOUTH)
					elif(r==TM.RIVER_E):
						plot=pmap.plot(x+1,y)
						if(not (plot.isWater() or pmap.plot(x,y).isWater())):
							plot.setNOfRiver(True,CardinalDirectionTypes.CARDINALDIRECTION_EAST)
					elif(r==TM.RIVER_W):
						plot.setNOfRiver(True,CardinalDirectionTypes.CARDINALDIRECTION_WEST)
		return 0
		
		
		#pmap.plot(xx-1,yy).setWOfRiver(True,CardinalDirectionTypes.CARDINALDIRECTION_NORTH)
		#pmap.plot(xx-1,yy).setNOfRiver(True,CardinalDirectionTypes.CARDINALDIRECTION_WEST)


	#adds a single bonus type
	def addBonusType(argsList):
		[bonus_type] = argsList
		gc = CyGlobalContext()
		map = CyMap()
		x_size = mc.x_size
		y_size = mc.y_size
		type_string = gc.getBonusInfo(bonus_type).getType()
		
		#these are the resources you find in water tiles
		resourcesWater = ('BONUS_CLAM', 'BONUS_FISH', 'BONUS_WHALE', 'BONUS_CRAB', 'BONUS_PEARL')
		#these resources should be given more often than others
		
		resourcesBasicFood=('BONUS_BANANA', 'BONUS_CORN', 'BONUS_COW', 'BONUS_DEER', 'BONUS_PIG', 'BONUS_RICE', 
		'BONUS_SHEEP', 'BONUS_WHEAT')
		
		resourcesCritical=('BONUS_COPPER','BONUS_IRON','BONUS_MITHRIL','BONUS_REAGENTS')
		
		resourcesLuxuries=('BONUS_GEMS','BONUS_GOLD','BONUS_DYE', 'BONUS_SILK','BONUS_WINE','BONUS_FURS','BONUS_COTTON','BONUS_IVORY')
		# we let the CivIV default system place critical resources
		if(type_string in resourcesCritical):
			CyPythonMgr().allowDefaultImpl()
			#return
		#resource level
		rl=int(map.getCustomMapOption(4))
		if(rl==1):
			rl=0.5
		elif(rl==2):
			rl=1.0
		elif(rl==3):
			rl=2.0

		resourcesAll=argsList

		#adjust levels of different resources
		count = x_size*y_size*rl*mc.RESOURCE_LEVEL
		count*=1.5
		#basic food resources are supposed to be common...
		if(type_string in resourcesBasicFood):
			count*=1.5
		elif(type_string=="BONUS_MANA"):
			count*=5.0
		elif(type_string in resourcesLuxuries):
			count*=2
		else:
			count*=1.0
		
		# this helps plains starts considerably
		if(type_string == 'BONUS_WHEAT'):
			count*=2.0
		count=int(count)
		if(rl!=0):
			eligible = []
			for x in range(x_size):
				for y in range(y_size):
					# First check the plot for an existing bonus.
					plot = map.plot(x,y)
					if plot.getBonusType(-1) != -1:
						continue # to next plot.
					if plot.getFeatureType() == gc.getInfoTypeForString("FEATURE_OASIS"):
						continue # Soren wants no bonuses in oasis plots. So mote it be.
					# Check plot type and features for eligibility.
					if (plot.canHaveBonus(bonus_type, False)):
						eligible.append([x,y])
					#deer are allowed in non-tundra forests....
					elif(type_string=="BONUS_DEER" and plot.getFeatureType()==gc.getInfoTypeForString("FEATURE_FOREST") and HM.HMData(x,y)<mc.MOUNTAIN_LIMIT):
						eligible.append([x,y])
					elif(type_string=="BONUS_MANA"  and HM.HMData(x,y)<mc.MOUNTAIN_LIMIT and HM.HMData(x,y)>0):
						eligible.append([x,y])
			while count > 0:
				if eligible == []: 
					break # No eligible plots left!
				index = int(rng()*len(eligible))
				[x,y] = eligible[index]
				map.plot(x,y).setBonusType(bonus_type)
				
				del eligible[index] # Remove this plot from the eligible list.
				count = count - 1  # Reduce number of bonuses left to place.
			# This bonus type is done.

		else:
			#this lets civ handle the resource in the default way
			CyPythonMgr().allowDefaultImpl() 

	def afterGeneration():#This comes before starting plot assignment
		print "Doing after-generation stuff"
		gc = CyGlobalContext()
		map = CyMap()

	    

	#Step 6: place all the players
	def assignStartingPlots():
		#grab all the plots in the map, sorted by their quality as starting locations
		gc = CyGlobalContext()
		map = CyMap()
		n_players=0
		for i in range(gc.getMAX_CIV_PLAYERS()):
			if gc.getPlayer(i).isEverAlive():
				n_players+=1
		plotlist = TM.GetBestStartingPositions(n_players)
		
		#f=open("E:\\blaah.txt","w")
		#for i in plotlist:
		#	f.write(str(i))
		#f.close()
		
		#if something goes wrong, allow default implementation
		if(len(plotlist)<n_players):
			CyPythonMgr().allowDefaultImpl()
			return
			
		#shuffle the players
		temp=[]
		while(len(plotlist)>0):
			temp.append(plotlist.pop(int(rng()*len(plotlist))))
		plotlist=temp
		
		position_index=0
		for i in range(gc.getMAX_CIV_PLAYERS()):
			if CyGlobalContext().getPlayer(i).isEverAlive():
				gc.getPlayer(i).setStartingPlot(map.plot(plotlist[position_index][0],plotlist[position_index][1]),True)
				position_index+=1
			#playerList = ShuffleList(playerList)

		return
""" """




"""end tag for editor (proper line with no indentation)"""
















